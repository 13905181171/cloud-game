package handler

import (
	"log"

	"github.com/giongto35/cloud-game/config"
	"github.com/giongto35/cloud-game/cws"
	"github.com/giongto35/cloud-game/webrtc"
	"github.com/gorilla/websocket"
)

// OverlordClient maintans connection to overlord
// We expect only one OverlordClient for each server
type OverlordClient struct {
	*cws.Client
	peerconnections map[string]*webrtc.WebRTC
}

// NewOverlordClient returns a client connecting to overlord for coordiation between different server
func NewOverlordClient(oc *websocket.Conn) *OverlordClient {
	if oc == nil {
		return nil
	}

	oclient := &OverlordClient{
		Client:          cws.NewClient(oc),
		peerconnections: map[string]*webrtc.WebRTC{},
	}
	return oclient
}

// RouteOverlord are all routes server received from overlord
func (s *Session) RouteOverlord() {
	iceCandidates := [][]byte{}
	oclient := s.OverlordClient

	// Received from overlord the serverID
	oclient.Receive(
		"serverID",
		func(response cws.WSPacket) (request cws.WSPacket) {
			// Stick session with serverID got from overlord
			log.Println("Received serverID ", response.Data)
			s.ServerID = response.Data

			return cws.EmptyPacket
		},
	)

	oclient.Receive(
		"initwebrtc",
		func(resp cws.WSPacket) (req cws.WSPacket) {
			log.Println("Received user SDP")
			localSession, err := s.peerconnection.StartClient(resp.Data, iceCandidates, config.Width, config.Height)
			if err != nil {
				if err != nil {
					log.Println("Error: Cannot create new webrtc session", err)
					return cws.EmptyPacket
				}
			}

			return cws.WSPacket{
				ID:        "sdp",
				Data:      localSession,
				SessionID: s.ID,
			}
		},
	)

	// Received start from overlord. This happens when bridging
	// TODO: refactor
	//oclient.Receive(
	//"start",
	//func(resp cws.WSPacket) (req cws.WSPacket) {
	//log.Println("Received a start request from overlord")
	//log.Println("Add the connection to current room on the host ", resp.SessionID)

	//peerconnection := oclient.peerconnections[resp.SessionID]
	//log.Println("start session")

	////room := s.handler.createNewRoom(s.GameName, s.RoomID, s.PlayerIndex)
	//// Request room from Server if roomID is existed on the server
	//room := s.handler.getRoom(s.RoomID)
	//if room == nil {
	//log.Println("Room not found ", s.RoomID)
	//return cws.EmptyPacket
	//}
	//s.handler.detachPeerConn(s.peerconnection)
	//room.AddConnectionToRoom(peerconnection, s.PlayerIndex)
	////roomID, isNewRoom := startSession(peerconnection, resp.Data, resp.RoomID, resp.PlayerIndex)
	//log.Println("Done, sending back")

	//req.ID = "start"
	//req.RoomID = room.ID
	//return req
	//},
	//)
	oclient.Receive(
		"start",
		func(resp cws.WSPacket) (req cws.WSPacket) {
			log.Println("Received a start request from overlord")
			log.Println("Add the connection to current room on the host ", resp.SessionID)
			s.startGameHandler(resp.Data, resp.RoomID, resp.PlayerIndex)
		},
	)
	// heartbeat to keep pinging overlord. We not ping from server to browser, so we don't call heartbeat in browserClient
}

func getServerIDOfRoom(oc *OverlordClient, roomID string) string {
	log.Println("Request overlord roomID ", roomID)
	packet := oc.SyncSend(
		cws.WSPacket{
			ID:   "getRoom",
			Data: roomID,
		},
	)
	log.Println("Received roomID from overlord ", packet.Data)

	return packet.Data
}

func (s *Session) startGameHandler(gameName, roomID string, playerIndex int) cws.WSPacket {
	s.GameName = gameName
	s.RoomID = roomID
	s.PlayerIndex = playerIndex

	log.Println("Starting game")
	// If we are connecting to overlord, request corresponding serverID based on roomID
	// TODO: check if roomID is in the current server
	room := s.handler.getRoom(s.RoomID)
	log.Println("Got Room from local ", room, " ID: ", s.RoomID)
	// If room is not running
	if room == nil {
		// Create new room
		room = s.handler.createNewRoom(s.GameName, s.RoomID, s.PlayerIndex)
		// Wait for done signal from room
		go func() {
			<-room.Done
			s.handler.detachRoom(room.ID)
		}()
	}

	// Attach peerconnection to room. If PC is already in room, don't detach
	log.Println("Is PC in room", room.IsPCInRoom(s.peerconnection))
	if !room.IsPCInRoom(s.peerconnection) {
		s.handler.detachPeerConn(s.peerconnection)
		room.AddConnectionToRoom(s.peerconnection, s.PlayerIndex)
	}
	s.RoomID = room.ID

	// Register room to overlord if we are connecting to overlord
	if room != nil && s.OverlordClient != nil {
		s.OverlordClient.Send(cws.WSPacket{
			ID:   "registerRoom",
			Data: s.RoomID,
		}, nil)
	}
	req.ID = "start"
	req.RoomID = s.RoomID
	req.SessionID = s.ID

	return req
}

//func (s *Session) bridgeConnection(serverID string, gameName string, roomID string, playerIndex int) {
//log.Println("Bridging connection to other Host ", serverID)
//client := s.BrowserClient
//// Ask client to init

//log.Println("Requesting offer to browser", serverID)
//resp := client.SyncSend(cws.WSPacket{
//ID:   "requestOffer",
//Data: "",
//})

//// Ask overlord to relay SDP packet to serverID
//resp.TargetHostID = serverID
//log.Println("Sending offer to overlord to relay message to target host", resp.TargetHostID, "with payload")
//remoteTargetSDP := s.OverlordClient.SyncSend(resp)
//log.Println("Got back remote host SDP, sending to browser")
//// Send back remote SDP of remote server to browser
//s.BrowserClient.Send(cws.WSPacket{
//ID:   "sdp",
//Data: remoteTargetSDP.Data,
//}, nil)
//log.Println("Init session done, start game on target host")

//s.OverlordClient.SyncSend(cws.WSPacket{
//ID:           "start",
//Data:         gameName,
//TargetHostID: serverID,
//RoomID:       roomID,
//PlayerIndex:  playerIndex,
//})
//log.Println("Game is started on remote host")
//}
